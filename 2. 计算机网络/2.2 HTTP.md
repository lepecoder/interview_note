## HTTP状态码

| 状态码 | 原因短语           | 含义                                                     |
| ------ | ------------------ | -------------------------------------------------------- |
| 100    | Continue           | 比如接收到post头后继续接受post数据部分                   |
| 200    | OK                 |                                                          |
| 301    | 永久移动           | 请求的URI资源路径已经改变，新的URI在响应头的Location字段 |
| 302    | 临时移动           |                                                          |
| 303    | 查看其它位置       | 引导浏览器使用GET方法访问其它URL                         |
| 304    | Not Modified       | 从缓存中直接取                                           |
| 403    | Forbidden          | 客户端未授权                                             |
| 404    | Not Found          |                                                          |
| 405    | Method Not Allowed |                                                          |
| 500    | 内部服务器错误     |                                                          |
| 501    | 未实现             |                                                          |
| 502    | 网关错误           |                                                          |

URI：资源是什么？
URL：资源是什么，如何获取？

## HTTP1.0

1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。

浏览器每次资源请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。

这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

*存在的问题：*

#### 无法复用连接

每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。

#### 队头阻塞（head of line blocking）

由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

## HTTP1.1

#### 增加长连接

 `connection: keep-alive`，可以复用TCP连接

在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。

#### 管道化：

默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

基于HTTP1.1的长连接，使得请求管线化成为可能。 管线化使得请求能够“并行”传输。

需要注意的是：服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。

也就是说，HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）

如果，客户端同时发了两个请求分别获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html，再发送css。 换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才开始传输，不允许同时存在两个并行的响应。

#### 多连接

现在的浏览器允许同时打开多个TCP连接，这才是真正的并行。

此外，HTTP1.1还加入了缓存处理（强缓存和协商缓存），新的字段如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）

## HTTP2

HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，

### 多路复用（链接共享）— 真并行传输

* 流（stream）：已建立连接上的双向字节流。
* 消息：与逻辑消息对应的完整的一系列数据帧。
* 帧（frame）：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流（stream_id）

所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。

每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（Stream_id）重新封装。

多路复用（连接共享）可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。

可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于“**二级制分帧**”的特性。

### 头部压缩

在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。

比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。

HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。

高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。

### 服务器推送

服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。

## 总结

### HTTP 1.0

无状态，无连接短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能无host头域，也就是http请求头里的host，不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象

### HTTP 1.1

长连接，流水线，使用connection:keep-alive使用长连接
请求管道化
增加缓存处理（新的字段如cache-control）
增加Host字段，支持断点传输等
由于长连接会给服务器造成压力

### HTTP 2.0

二进制分帧头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求服务器推送（Sever push）

### HTTP 3.0

基于google的QUIC协议，而quic协议是使用udp实现的减少了tcp三次握手时间，以及tls握手时间解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接更合适的流量控制基于UDP实现，0RTT建连，基于UDP的多路复用，加密认证的报文，向前纠错机制

## 无状态的HTTP如何保存用户状态

通常有两种解决方案：

① 基于 Session 实现的会话保持

在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。

优点：安全性高，因为状态信息保存在服务器端。

缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。

【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】

② 基于 Cookie 实现的会话保持

当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。

优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。

缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。

拓展：Cookie被禁用了怎么办？

若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。

## Cookie

Session、Cookie和Token的主要区别
HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。

cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。

### Cookie的缺点

## Session

session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。

## cookie与session区别

存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；
存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制
占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。

## 浏览器的本次存储

### sessionStorage

### localStorage