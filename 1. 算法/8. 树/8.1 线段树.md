## 线段树

> 线段树用于维护区间信息，用于对数组中的区间进行修改，可以是加乘操作(需要满足结合律)，最大值最小值，和传统的O(n)时间复杂度相比，线段树可以实现O(logn)的时间复杂度。
>
> 符合区间加法的例子：
> 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和
> 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );
> 最大值——总最大值=max(左区间最大值，右区间最大值)
>

线段树和树状数组、前缀和有些相似，都可以用来求区域的和，根据问题的不同有如下选择；

* 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
* 多次修改某个数，求区间和：「树状数组」、「线段树」
* 多次整体修改某个区间，求区间和：「树状数组」、「线段树」
* 多次将某个区间变成同一个数，求区间和：「线段树」

线段树是一棵**平衡二叉树** 。母结点代表整个区间的和，越往下区间越小。

![](https://pic1.zhimg.com/80/v2-5e9124a6147143e51cea46755e9a0398_720w.jpg)

### 建立线段树

可以考虑递归的建立，使用首递归，则当前节点的值就是左右子树的和。

```cpp
void build(ll l = 1, ll r = n, ll p = 1){
    // p是节点序号
    if (l == r) // 到达叶子节点
        tree[p] = A[l]; // 用数组中的数据赋值
    else {
        ll mid = (l + r) / 2;
        build(l, mid, p * 2); // 先建立左右子节点
        build(mid + 1, r, p * 2 + 1);
        tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 该节点的值等于左右子节点之和
    }
}
```

### 区间修改

线段树的区间修改创意性的引入了一个**懒标记**的概念，通常的方法修改一个区间需要一直修改到叶子节点，懒标记的作用：如果线段树位于修改区间内，使用懒标记表说明当前节点已经更新，不继续递归下去，在之后访问或是更新到子节点时传递懒标记，实现延时更新。

懒标记表示子树还未提交的更新。

```cpp
void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n){
/*
l和r是需要修改的区间范围，d是每个节点修改的大小，p是当前节点，cl和cr是当前节点的范围
1. 修改范围和当前节点范围无交集，直接退出
2. 当前节点范围位于修改范围内，修改当前节点值，如果不是叶子节点，打上标记，表明叶子节点有未提交的修改
3. 当前节点部分位于修改范围内，需要修改之后的节点，此时如果当前的懒标记表明有未提交的修改应该向下传递
*/
    if (cl > r || cr < l) // 区间无交集
        return; // 剪枝
    else if (cl >= l && cr <= r) { // 当前节点对应的区间包含在目标区间中
        tree[p] += (cr - cl + 1) * d; // 更新当前区间的值
        if (cr > cl) // 如果不是叶子节点
            mark[p] += d; // 给当前区间打上标记, 子树还有mark[p]需要更新
    }
    else // 与目标区间有交集，但不包含于其中
    {
        ll mid = (cl + cr) / 2;
        mark[p * 2] += mark[p]; // 标记向下传递
        mark[p * 2 + 1] += mark[p];
        tree[p * 2] += mark[p] * (mid - cl + 1); // 往下更新一层
        tree[p * 2 + 1] += mark[p] * (cr - mid);
        mark[p] = 0; // 清除标记
        update(l, r, d, p * 2, cl, mid); // 递归地往下寻找
        update(l, r, d, p * 2 + 1, mid + 1, cr);
        tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 根据子节点更新当前节点的值
    }
}
```

这里我们将p的懒标记向下传递了一层，由于之后的区间查询还要用到，因此我们可以将懒标记的向下传递包装成一个函数

```cpp
inline void push_down(ll p, ll len){
// len是p的区间长度
    mark[p * 2] += mark[p];
    mark[p * 2 + 1] += mark[p];
    tree[p * 2] += mark[p] * (len - len / 2);
    tree[p * 2 + 1] += mark[p] * (len / 2); // 右边的区间可能要短一点
    mark[p] = 0;
}
```

### 区间查询

```cpp
ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n){
/*
查询区间是l,r节点区间是cl,cr,节点序号是p
1. 如果查询区间和节点区间不想交，返回0
2. 如果查询区间刚好等于节点区间，返回节点值
3. 如果部分相交，递归的返回之后的查询结果，由于需要访问子节点，此时要更新懒标记
*/
    if (cl > r || cr < l)
        return 0;
    else if (cl >= l && cr <= r)
        return tree[p];
    else {
        ll mid = (cl + cr) / 2;
        push_down(p, cr - cl + 1);
        return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); 
        // 上一行拆成三行写就和区间修改格式一致了
    }
}
```