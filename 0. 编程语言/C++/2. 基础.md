## C 和 C++ struct 的区别？

* 在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。
* C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。
* C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var;

## struct 和 union 的区别

说明：union 是联合体，struct 是结构体。
区别：

1. 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
2. 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。
3. 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。

## C++ 中class和struct的区别

* struct 和 class 都可以自定义数据类型，也支持继承操作。
* struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。
* 当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身， class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。

## C++基础知识

在climits中定义了各种数据类型的范围

* `#define`宏定义，预编译命令，用于将一个标识符定义为一个字符串。在编译阶段，标识符会被简单的替换为字符串。比如`#define inf 0x3f3f3f3f`
* 有参数的宏定义，`#define`允许标识符带有参数，`#define add(x,y) (x+y) `
* 还可以用来做条件编译，使用`#ifndef`做条件编译，避免嵌套包含。
* `typedef`用来为现有的类型创建一个新的名字，和`#define`的顺序相反
  `typedef unsigned char UBYTE;`
* `typedef`可以用来为结构体创建一个新的名字。
* `using`C++11中提出的 `using ty = unsigned char;`
  和define这种简单的预编译命令同步，C++11中更推荐用using，替换会更智能。

## 内存模型

内存区域：

* 栈：存放函数的参数值，临时变量等，由于维护函数调用的上下文，由操作系统分配和释放，操作方式类似于数据结构中的栈。
* 堆：程序动态分配的内存区域，由程序员手动释放和回收。分配方式类似于链表。
* 全局区(静态存储区)：存放全局变量和静态变量，程序结束后自动释放。
* 自由存储区：自由存储是C++中通过new与delete动态分配和释放对象的 **逻辑概念** ，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
* 常量存储区：存储的常量，不允许修改。
* 代码区：二进制代码

#### 栈

栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：

* 函数的返回地址和参数
* 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
* 保存上下文：包括函数调用前后需要保持不变的寄存器

#### 堆

堆分配算法：

* 成组链接法
* 位图（Bitmap）

堆和栈的区别：

* 栈是系统管理，堆是程序员管理
* 分配方式不同，
  **分配栈空间**，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请**堆空间**，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
* 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
* 栈在linux大小默认8M，可以通过`ulimit -a`查看，通过`ulimit -s`修改；堆理论上内存多大就可以多大。
* 栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

## C语言中结构体和C++中结构体的区别

C++中的结构体就是class，可以有成员函数，可以有虚函数，可以继承和被继承，可以定义构造函数，可以直接用结构体名创建变量，`结构体的默认访问权限是public，而类的默认访问权限是private。`

C语言中结构体只能有变量，不能有函数，必须通过`struct`+结构体名声明变量，

## 作用域

* 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
* 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
* 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
* 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

### 全局变量不能定义在头文件中

如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。

`#ifndef`只防止某.c重复include同一头文件
不同.c去include同一头文件是可以的；如果这个头文件里定义了全局变量，每个include该头文件的.c都会生成各自的同名全局变量，导致重复定义

## decltype

decltype被称作类型说明符，它的作用是选择并返回操作数的数据类型。

decltype + var

```cpp
const int ci = 0, &cj = ci;
// x的类型是const int
decltype(ci) x = 0;
// y的类型是const int &
decltype(cj) y = x;
// 相当于 zeros_like是拷贝维度，它是创建相同类型的变量
```

decltype + expr  ②当使用decltype(expr)的形式时，decltype会返回表达式结果对应的类型。

```
int i = 42, *p = &i, &r = i;
// r + 0是一个表达式
// 算术表达式返回右值
// b是一个int类型
decltype(r + 0) b;
// c是一个int &
decltype(*p) c = i;
```

decltype + function 返回函数类型，主要是为了定义函数指针

```
// 声明了一个函数类型
using FuncType = int(int &, int);
// 下面的函数就是上面的类型
int add_to(int &des, int ori);
// 声明了一个FuncType类型的指针
// 并使用函数add_to初始化
FuncType *pf = add_to;
decltype(add_to) *pf = add_to;
int a = 4;
// 通过函数指针调用add_to
pf(a, 2);
```