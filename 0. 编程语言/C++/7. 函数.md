### 函数

函数原型--函数定义--函数调用

那么函数声明是什么??

我~~一直以为~~函数原型就是声明，毕竟：

```cpp
int cheers(int x); // 变量名x不是必须的
```

当函数定义在main()之后时，函数原型是必须的。

C++不能省略函数声明(原型)但可以把声明和定义放在一起。

#### 函数和二维数组

```cpp
int sum(int (*ar1)[4], int size); //函数声明表示数组的元素是包含4个int型整数的数组。
int sum(int ar2[][4], int size); //也可以这样声明
```

我们必须声明数组的列长，因为在做索引`arr[2][3]`的时候，因为二维数组仍是线性存储，没有列长无法定位第二行在哪。

#### 函数指针

和数据项相似，函数也有地址，函数的地址就是存储它的内存的开始地址，我们可以将函数a的地址当做参数传递给函数b，这样在b中就可以执行a，这样我们可以根据不同的条件执行不同的函数。

**函数的地址**就是函数名，这样意味着，如果我们要把函数地址作为参数，只需要`process(think);`，函数的地址不带括号。

**函数指针的声明**类似函数的声明，只是类型不同

```cpp
double pam(int);  //函数声明
double (*pm)(int); //函数指针声明，
double *pm(int);  //也是函数声明，但返回值是指向double的指针
```

声明指针后就可以赋给它函数的地址，比如

```cpp
pm = pam; //就是这样
// 如果要作为参数传递给其它函数，
void estimate (int lines, double (*pf)(int)){
  ...
}
```

由于`pm`是函数指针，那么`*pm`就是函数，使用时只需要`(*pm)(4)`就行。

不过C++允许直接将函数指针当做函数调用，即`pm(4)`。

#### 内联函数

编译器直接使用函数代码替换函数调用，程序无需跳到另一个位置执行代码，由于多次调用，程序的体积可能增大。

在声明和定义前加上`inline`就行。

类似的有宏定义，`#define(x) x*x`，这是通过文本替换实现的。

#### 引用变量

引用是已定义的变量的别名，比如

```cpp
int a;
int & b = a; // makes b as alias for a
```

这里的`&`是不是取地址，是类型标识符，表明b是a的引用，这意味着改变b同时改变a。

**引用与指针的区别**

引用创建后不能更改，相当于静态的指针，

```cpp
int a;
int &b = a; //reference
int * const pr = &a; //pointer
// *pr的用法和b差不多

void swapr(int &a, int &b);
```

#### 函数重载

又称多态，函数名相同但参数列表不同，根据不同的调用参数调用不同的函数。

```cpp
void print(double a);
void print(int a);
```

#### 函数模板

函数模板可以用任意类型的方式定义函数，比如swap(int,int)和swap(double,doubel)当函数功能相同但参数类型不同时，可以使用函数模板。

```cpp
template <typename T>
void swap(T &a, T &b);
```

显示具体化(explicit specialization)

对于一个函数名，可以有非模板函数、显示具体化模板函数和模板函数以及他们的重载版本。

显示具体化和显式实例化。

显式实例化是在函数调用时显式指明模板类型、

#### 常量函数

const int get(const int x) const{};

第一个const表示返回常量类型
第二个const表示参数不能被修改
第三个const表示get()函数不会修改所属对象的数据成员