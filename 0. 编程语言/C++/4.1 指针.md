#### 指针

数据存储的3个基本属性

["C++ 对信息的处理只会关心3中基本的属性信息存储在何处；存储的值是多少；存储的信息是什么类型；"](siyuan://blocks/20210316201701-uklk0t6)

指针也是一个变量，只不过存储的值是内存地址；我们可以使用取地址符得到一个变量的地址 `&var`

我们可以使用`*`运算符取得地址处的值，`*`被称为间接值或解除引用运算符。由于指针只记录变量在内存的起始地址，我们在声明时还需要说明指针指向的值的类型以说明变量占用的内存长度

```cpp
int * P_updates; // 左右的空格是可选的
int *p_updates;  // 强调*p_updates是int类型
int* p_updates;  // 强调 p_updates是int* 类型
```

在C++中，int*是一种复合类型，表示指向int的指针。

##### 指针的危险

C++创建指针时不会初始化指针所指向的内存地址，因此使用指针时记得要赋给有效地址，比如

```cpp
int *p;
*p = 123;
```

这里p指向的地址并没有被初始化，可能是其它程序正在使用的地址，没有实际意义。所以一定要在使用`*`之前为指针初始化一个确定的地址。

指针的作用在于运行时分配内存，C++使用new运算符找到未命名的内存以存储值，并返回该内存块的地址，所以我们可以对指针在运行时初始化。

```cpp
int* pn = new int;  
// 等价于
int a;
int* pn = &a;
```

使用和`new`对应的`delete`释放内存，使用new申请的内存不会纳入C++自动内存管理，参考["3.1 存储类"](siyuan://blocks/20210313145744-s9htl8r)，所以我们需要手动delete。

```cpp
int *ps = new int;
...
delete ps;  //释放内存，不会删除ps指针本身，他仍然可以指向新的地址。

int a = 3;
int *p = &a;
delete p; // 不能释放自动管理的变量的内存
```

##### 动态数组

和创建变量一样，只是new的是一个数组空间，此时数组的大小可以是变量

```cpp
int n = 10;
int *p = new int [n];
...
delete [] p;
```

数组也是一种指针，数组名指向了数组中第一个元素的内存位置。

对指针的`+1`相当于指针向右偏移一个元素长度。

**二维动态数组：**

二维数组是指针组成的数组，数组中的元素是指针，而每个指针又指向一个数组，由于二维数组是线性存储的，因此列的大小必须是固定的。

```cpp
int *dp[n1+1]; // 建立指针数组
for (int i = 0; i <= n1; i++) { dp[i] = new int[n2 + 1]; }
```

C++会将数组名视为指针，所以下式是成立的

```cpp
int cookies[];
cookies == &cookies[0];
```

##### 动态结构

结构体是用户自定义的数据类型，当然也可以用`new`动态创建，唯一不同的是结构指针指向的是地址而不是结构名，因此访问成员时不能用`.`成员运算符，而是箭头成员运算符`->`。当然，也可以使用解除引用运算符`(*ps).price`。

##### 指针数组和数组指针