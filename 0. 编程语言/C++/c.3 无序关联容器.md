## 无序关联容器

和关联容器类似，只不过关联容器中的元素会按照key排序，查找时间复杂度是O(logn)而无序关联容器使用hash存储，查找复杂度是O(1)。

无序关联容器的查找效率高，但是空间利用率低。

| 无序容器           | 功能                                                                                                                                                                                                                                  |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。                                                                                                                                  |
| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。                                                                                                                                                                   |
| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |
| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。                                                                                                                                                                         |

> 总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。
>

### 底层实现机制

C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”

![C++ STL 无序容器存储状态示意图](http://c.biancheng.net/uploads/allimg/200221/1-200221131A4220.gif)

可以看到，当使用无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不用来直接存储键值对，而是存储各个链表的头指针，各键值对真正的存储位置是各个链表的节点。

将图 1 中的各个链表称为桶（bucket），每个桶都有自己的编号（从 0 开始）。当有新键值对存储到无序容器中时，整个存储过程分为如下几步：

1. 将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；
2. 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；
3. 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上。

负载因子 = 容器存储的总键值对 / 桶数

所有的无序容器都有如下方法：

| 成员方法           | 功能                                                                                                                                                                                                    |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| bucket_count()     | 返回当前容器底层存储键值对时，使用桶的数量。                                                                                                                                                            |
| max_bucket_count() | 返回当前系统中，unordered_map 容器底层最多可以使用多少个桶。                                                                                                                                            |
| bucket_size(n)     | 返回第 n 个桶中存储键值对的数量。                                                                                                                                                                       |
| bucket(key)        | 返回以 key 为键的键值对所在桶的编号。                                                                                                                                                                   |
| load_factor()      | 返回 unordered_map 容器中当前的负载因子。                                                                                                                                                               |
| max_load_factor()  | 返回或者设置当前 unordered_map 容器的最大负载因子。                                                                                                                                                     |
| rehash(n)          | 尝试重新调整桶的数量为等于或大于 n 的值。如果 n 大于当前容器使用的桶数，则该方法会是容器重新哈希，该容器新的桶数将等于或大于 n。反之，如果 n 的值小于当前容器使用的桶数，则调用此方法可能没有任何作用。 |
| reserve(n)         | 将容器使用的桶数（bucket_count() 方法的返回值）设置为最适合存储 n 个元素的桶数。                                                                                                                        |
| hash_function()    | 返回当前容器使用的哈希函数对象。                                                                                                                                                                        |