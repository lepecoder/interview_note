## 概念

### C++的特性

> 封装、继承和多态
>

## 基本语法

### 指针数组和数组指针

指针数组就是指向指针的数组，数组中*的元*素存**储某个**类型的指针，比如指向char数组，或是int

### 引用与指针有什么区别？

> 1. 引用必须被初始化，指针不必。
> 2. 引用初始化以后不能被改变，指针可以改变所指的对象。
> 3. 不存在指向空值的引用，但是存在指向空值的指针。
>

### NULL与nullptr

NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。
nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。

函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。

nullptr是指针类型，而且可以转换为任意类型的指针。

### inline关键字，什么时候慎用

内联函数不能有复杂的分支和循环，因为编译器会在调用点展开函数代码，如果是复杂函数，调用开销占比不大，还会增加编译时间。

### 指针和引用的区别

* 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
* 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）
* 指针可以为空，但是引用必须绑定对象。（是否可为空）
* 指针可以有多级，但是引用只能一级。（是否能为多级）  int **p, int &&a

### 假设C继承了A和B，AB都有虚函数，然后C也有自己的虚函数，那么C的虚函数表

### 野指针与悬空指针

悬空指针：

若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。

野指针：

“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。

### 深拷贝和浅拷贝

如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。

* 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。
* 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。

### 拷贝构造函数的参数为什么必须是引用

避免拷贝构造函数无限制的递归，最终导致栈溢出。*如果是传值，会生成一个临时变量，又要调用拷贝构造。*

* 说明 1：ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？
  对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值函数；但是 ex3 还没有实例化，因此调用的是拷贝构造函数，构造出 ex3，而不是赋值函数，这里涉及到构造函数的隐式调用。
* 说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 = ex1;会出现什么问题？
  **简而言之**，形参如果是值传递，就又会引起拷贝。
  构造 ex3，实质上是 ex3.A(ex1);，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp)的形参，在参数传递时相当于 A tmp = ex1，因为 tmp 没有被初始化，所以在 A tmp = ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1) ，必然又会有 ex1 作为函数 A(const A tmp); 的形参，在参数传递时相当于即 A tmp = ex1，那么又会触发拷贝构造函数，就这下永远的递归下去。

## 内存管理

### new、delete、malloc、free关系

> new和delete是C++运算符，new会调用构造函数，delete会调用析构函数，是C++新增面向对象特性后增加的操作符，因为对象在创建时需要自动执行构造函数，销毁前要执行析构函数。
> malloc和free是库函数而不是运算符，不能被编译器控制，不能够把执行构造函数和析构函数的任务强加于malloc/free，只负责申请和释放内存。
>

* malloc、free 是**库函数**，而new、delete 是**关键字**。
* new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。
* new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。
  new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。
  对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。
  new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

### delete与 delete []区别

> delete[]和new[]对应，delete[]会调用每一个成员的析构函数，单独的delete会解放由new申请的内存，但是只会调用delete a[0]的析构函数。
>

## C++11

### 智能指针

["g.1 智能指针"](siyuan://blocks/20210724160742-v9vixo7)

### 类型推导

["类型推导"](siyuan://blocks/20210801161755-btu1mq0)

### 移动构造函数和拷贝构造函数

["移动语义"](siyuan://blocks/20210717203913-l9c5bxk)

## 多态

我们定义的是**函数模板**，通过用不同的参数去调用编译器会生成新的函数，称为**模板函数**。

编译时多态通过重载实现，函数的参数列表不同。
运行时多态通过重写实现，利用虚函数。

## 类和继承

*父类的析构函数一定要声明成虚函数*，不然可能有内存泄露

### **静态函数可以声明为虚函数吗？**

不可以，原因有两方面：

* static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义
* 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。

### 派生类初始化时是否要调用基类的构造函数? 销毁时呢?

> 派生类在初始化时要先调用基类的构造函数，得到基类的对象进而添加基类的成员；
> 在销毁时相反，要先调用派生类的析构函数，最后再调用基类的析构函数。
>

### 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？

> 基类的构造与析构函数 和 派生类中构造与析构函数 的名字都不一样，即使使用virtual，怎么能实现基类指针访问到派生类虚函数实现上的呢？
> 但是*析构函数一定要声明为虚函数，不然可能有内存泄露*
>
> 详见["虚函数"](siyuan://blocks/20210329150344-im9okbr)
>

### 为什么构造函数不能是虚函数

> 不可以，因为虚函数存在的唯一目的就是为了多态。而子类并不继承父类的构造函数，构造函数是创建对象时自己主动调用的，不可能被继承，所以没有使父类构造函数变成虚函数的必要。父类在构造函数中创建虚函数表，实例化类对象，如果构造函数成为虚函数，那么因为类对象没有实例化导致不可能后续出现虚函数。
>

### 什么是 C++ 多态？C++ 多态的实现原理是什么？

> 多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。运行时的多态则和虚函数、继承有关。
>

### 重载(overload)和重写(override)

> 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
>
> 重写：是指子类重新定义父类虚函数的方法。
>
> 从实现原理上来说：
>
> 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载编译时多态。
>
> 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。
>

### 什么是“引用”？申明和使用“引用”要注意哪些问题？

> 引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
>

### 将“引用”作为函数参数有哪些特点？

> （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
>
> （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
>
> （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
>

### 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?

> 在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!
> 不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
> 流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用
>

### 结构与联合有和区别？

> (1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
>
> (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
>

### 什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？

["虚函数表"](siyuan://blocks/20210329150352-ugz2uzv)

### 菱形继承（类 D 同时继承 B 和 C，B 和 C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？

### 不能建立引用的数组，但是可以建立数组的引用

```cpp
// 引用的数组
int &ref[3] = {2,3,4};  //error，引用没有内存空间，不能
```

### 什么时候只能使用列表初始化

* const常量成员的初始化只能在构造函数的初始化列表中
* 引用成员的初始化
* 成员对象(类对象作为成员)的初始化，如果没有默认构造函数，也只能使用列表初始化

### 有哪几种情况只能用intialization list 而不能用assignment?

### C++是不是类型安全的？

> 答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C是*类型安全*的
>

### main 函数执行以前，还会执行什么代码？

> 全局对象的构造函数会在main 函数之前执行。
>

### 描述内存分配方式以及它们的区别?

> 1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
>
> 2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集，效率很高
>
> 3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。
>

### 请说出const与\#define 相比，有何优点？

> const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
>
> 1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
>
> 2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。
>

### 简述数组与指针的区别？

> 全局数组在静态存储区上被创建，函数内的数组在栈上创建，而指针可以指向任意类型的内存块。
>
> 如果把临时变量赋给普通变量的话，会给临时变量会存到普通变量的位置
>
> ```cpp
> char a[] = "hello";
> a[0] = 'x';  //此时可以修改
> ```
>
> 但如果将临时变量赋给指针，由于指针并不真实开辟空间，所以修改时会发生错误，严格来讲，即便不修改， 也不能让指针指向临时变量。
>
> ```cpp
> char *p = "hello";
> p[0] = 'x'; 
>
> ```
>
> 数组会开辟空间，指针不会开辟空间，所以将相同的"abc"赋给数组，==也是false。
> 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
>

### int (*s[10])(int) 表示的是什么？

> int *f(int) 是一个指向函数的指针，那么`int (*s[10])(int)`就是函数指针数组。
>

### int id[sizeof(unsigned long)];

> 通常来讲，int[]数组不能申请变量大小的空间，但是sizeof是编译时运算符，在编译时就确定，可以认为是和机器有关的常量。
>

### A,B两个类，类中有虚函数。C继承AB，有几张虚函数表？

> 答：2张。多继承就会有多个虚函数表。因为每个父类的虚函数是不同的，指针也是不同的。如果共用一张虚函数表，就分不清到底子类的实例化是针对哪一个基函数的。
>

### 父类构造函数中是否可以调用虚函数？

> 详见["构造函数中调用虚函数"](siyuan://blocks/20210423204920-jizw11v)
>

### 类的静态成员变量不能用参数初始化表初始化

> （1） 如果声明了类而未定义对象，则类的一般数据成员是不占内存空间的，只有在定义对象时，在运行的时候才为对象的数据成员分配空间。但是静态数据成员不属于某一个对象，在为对象所分配的空间中不包括静态数据成员所占的空间。静态数据成员是在所有对象之外单独开辟空间，也就是在静态变量区。只要在类中指定了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被引用。
>
> （2） 一般的类的成员随对象的建立而分配空间，随对象的撤销而释放。静态数据成员是在程序编译时被分配空间的，至程序结束时才释放空间。
>
> （3） 静态数据成员可以初始化，但只能在类体外进行初始化。
>