## vector容器

动态数组，在插入的过程中vector会动态调整占用的内存空间。

关于vector空间分配可以在之后effective STL 补充。

vec.reserve(20);  设置容器的内存分配，至少容纳20个元素。

常用的初始化方式`vector<int> vec(20,1)`，初始化为20个1。

vector特殊的函数

| 函数成员         | 函数功能                                                              |
| ---------------- | --------------------------------------------------------------------- |
| size()           | 实际元素个数                                                          |
| resize()         | 改变实际元素的个数，如果小于是几个数，去前n个，如果大于，后面补默认值 |
| capacity()       | 返回容器的容量                                                        |
| reserve()        | 增加容器的容量                                                        |
| shrink _to_fit() | 将内存减少到等于当前实际所使用的大小                                  |
| assign()         |                                                                       |
| erase()          | 移除一段元素                                                          |
| emplace()        | 在指定位置直接生成一个元素                                            |
| emplace_back()   | 在序列尾部直接生成一个元素                                            |
| front()          | 返回第一个元素的引用                                                  |

**注意：**

在vector扩容时，可能会将元素移动到新的位置，这会导致之前创建的迭代器失效。
对于空的容器，begin()和end()返回的迭代器指向相同的位置。

### push_back()和emplace_back()

push_back()已经很熟悉了，emplace_back()是C++11新特性，功能和push_back()相同，都是在尾部添加元素，但是底层实现机制不同。

- push_back()会首先创建这个元素，然后拷贝或移动到容器中
- emplace_back()会直接在容器尾部创建元素，省去了拷贝或移动的过程。

因此emplace_back()效率更高，会少调用一次拷贝(移动)构造函数。

### insert()和emplace()

insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素.

| 语法格式                        | 用法说明                                                                                                                                        |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。                                                               |
| iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。                                                         |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。         |
| iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

emplace() 是 [C++](http://c.biancheng.net/cplus/) 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。

> 再次强调，emplace() 每次只能插入一个元素，而不是多个。
>

该函数的语法格式如下：

```cpp
iterator emplace (const_iterator pos, args...);
```

其中，pos 为指定插入位置的迭代器；args... 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。> 简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传cpp入相应数量的参数。

emplace()效率更高，但一次只能插入一个元素。

### 删除元素的几种方式

对vector容器的访问和插入元素都只能用vector提供的成员函数，但是删除元素除了用成员函数还有一些全局函数。

| 函数                  | 功能                                                                                                                                                                 |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| pop_back()            | 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。                                                                         |
| erase(pos)            | 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。              |
| swap(beg)、pop_back() | 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。                                                                 |
| erase(beg,end)        | 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 |
| remove()              | 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。                                   |
| clear()               | 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。                                                     |

### remove()

remove并不是vector的成员函数，而是定义在algorithm中的函数，他并不会改变vector的大小，而是会把指定元素用后面的非指定元素覆盖。

```cpp
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    vector<int>demo{ 1,3,3,4,3,5 };
    //交换要删除元素和最后一个元素的位置
    auto iter = std::remove(demo.begin(), demo.end(), 3);
    cout << "size is :" << demo.size() << endl;  // size=6
    cout << "capacity is :" << demo.capacity() << endl;  //capacity=6
    //输出剩余的元素
    for (auto first = demo.begin(); first < iter;++first) {
        cout << *first << " "; // 1 4 5
    }// 实际上是1 4 5 4 3 5
    return 0;
}
```

这种覆盖并不会改变后面的元素，因此如果用end()作为边界条件，仍然会输出之后的元素。

但我们可以配合erase()删掉之后无用的元素

```cpp
auto iter = std::remove(demo.begin(), demo.end(), 3);
demo.erase(iter, demo.end());
```

### vector的容量capacity()

vector 容器扩容的整个过程，和 realloc() 函数的实现方法类似，大致分为以下 4 个步骤：

1. 分配一块大小是当前 vector 容量几倍的新存储空间。注意，多数 STL 版本中的 vector 容器，其容器都会以 2 的倍数增长，也就是说，每次 vector 容器扩容，它们的容量都会提高到之前的 2 倍；
2. 将 vector 容器存储的所有元素，依照原有次序从旧的存储空间复制到新的存储空间中；
3. 析构掉旧存储空间中存储的所有元素；
4. 释放旧的存储空间。

扩容操作是非常耗时的，因此我们应该在初始化时给定合适的大小。

| 成员方法   | 功能                                                                                                                                                                                                                                                                                                |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| size()     | 告诉我们当前 vector 容器中已经存有多少个元素，但仅通过此方法，无法得知 vector 容器有多少存储空间。                                                                                                                                                                                                  |
| capacity() | 告诉我们当前 vector 容器总共可以容纳多少个元素。如果想知道当前 vector 容器有多少未被使用的存储空间，可以通过 capacity()-size() 得知。注意，如果 size() 和 capacity() 返回的值相同，则表明当前 vector 容器中没有可用存储空间了，这意味着，下一次向 vector 容器中添加新元素，将导致 vector 容器扩容。 |
| resize(n)  | 强制 vector 容器必须存储 n 个元素，注意，如果 n 比 size() 的返回值小，则容器尾部多出的元素将会被析构（删除）；如果 n 比 size() 大，则 vector 会借助默认构造函数创建出更多的默认值元素，并将它们存储到容器末尾；如果 n 比 capacity() 的返回值还要大，则 vector 会先扩增，在添加一些默认值元素。      |
| reserve(n) | 强制 vector 容器的容量至少为 n。注意，如果 n 比当前 vector 容器的容量小，则该方法什么也不会做；反之如果 n 比当前 vector 容器的容量大，则 vector 容器就会扩容。                                                                                                                                      |