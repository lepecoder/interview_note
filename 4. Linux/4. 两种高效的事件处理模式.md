Linux需要处理三类事件，IO事件、信号、定时事件。同步IO模型通常用来实现Reactor模式；异步IO模型用于Proactor模式。

## 事件处理模式

### Reactor

主线程只负责监听文件描述符上是否有事件发生，有的话就将事件通知工作线程，主线程不做其它实质性工作。读写数据、接收连接、处理客户请求都在工作线程中完成。同步IO模型

1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。
2. 主线程调用 epoll_wait 等待 socket 上有数据可读。
3. 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程则将可读事件放入请求队列。
4. 睡眠在请求队列上某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。
5. 主线程调用 epoll_wait 等待 socket 可写。
6. 当 socket 可写，epoll_wait 通知主线程。主线程则将可写事件放入请求队列。
7. 睡眠在请求队列上某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。

![image.png](assets/image-20210827162849-boocrrb.png)

### Proactor

主线程和内核负责所有的IO操作，工作线程仅负责业务逻辑。异步IO模型

1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。
2. 主线程继续处理其它逻辑。
3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
4. 应用程序预知先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
5. 主线程继续处理其它逻辑。
6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。

![image.png](assets/image-20210827165305-t3lnfwo.png)