## 基本概念

### 同步和异步

*取决于消息的通知机制*

同步：发出调用，在没有结果之前，调用不返回。

异步：在发出调用后，调用者不能立即得到结果，在调用处理函数结束后，通过信号、通知、回调来通知调用者

### 阻塞与非阻塞

*取决于**等待消息通知时的状态*

阻塞调用：调用结果返回前，当前线程会被挂起，其它线程可以执行。

非阻塞调用：函数调用不会阻塞当前线程，而是会立刻返回，并设置相应的errno。

**阻塞和同步是完全不同的概念。首先，同步是对于消息的通知机制而言，阻塞是针对等待消息通知时的状态来说的。而且对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。**

### 实例

①、**同步阻塞：**小明一直盯着下载进度条，到 100% 的时候就完成。
　　同步：等待下载完成通知；
　　阻塞：等待下载完成通知过程中，不能做其他任务处理；

②、**同步非阻塞：**小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。

　　同步：等待下载完成通知；
　　非阻塞：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】

③、**异步阻塞：**小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。

　　异步：下载完成“叮”一声通知；
　　阻塞：等待下载完成“叮”一声通知过程中，不能做其他任务处理；

④、**异步非阻塞：**仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。
　　异步：下载完成“叮”一声通知；
　　非阻塞：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知。

# 五种IO模型

Linux中IO执行包括两个阶段，①内核缓冲区 ②应用程序缓冲区

对于一次IO读取操作，数据会先到达①，在拷贝到②；
对于套接字上的输入操作，会先等待数据从网络中到达①，之后拷贝到②。

## 阻塞式IO

![image.png](assets/image-20210826201756-g1enysi.png)

在调用rescfrom过程中，不能立刻收到回复，直到数据从内核返回到程序空间。在过程中进程处在阻塞态，不能做其它任务。

## 非阻塞式IO

![image.png](assets/image-20210826205523-rqe2y9c.png)

非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个errno。进程在返回之后，可以处理其他的业务逻辑，过会儿再发起recvform系统调用。采用轮询的方式检查内核数据，直到数据准备好。再拷贝数据到进程，进行数据处理。

*在拷贝数据报时仍然阻塞*

## IO多路复用

*使得单个进程可以同时处理多个网络连接的IO*

基本原理是不再由应用程序自己监视连接，取而代之由内核替应用程序监视文件描述符。通常用于以下情形：

* 客户端同时处理多个socket，比如非阻塞connect
* 客户端同时处理用户输入和网络连接，比如聊天室
* 服务器同时处理监听socket和连接socket

### select

![image.png](assets/image-20210826212051-crkd31p.png)

select函数传入要监听的文件描述符数组，在调用select时进程*阻塞*，直到集合中任意个套接字变为就绪状态或超时。就绪状态指的是可读、可写、异常。数组有最大长度，因此一般select只能管理不超过1k个IO操作

可读状态：

1. 内核缓冲区的字节数大于阈值
2. socket通信的对方关闭连接
3. 监听socket有连接请求
4. socket有未处理的错误

可写状态：

### poll

本质和select类似，将文件描述符数组拷贝到内核空间，内核查询fd状态。但是poll使用链表存储，没有最大连接数限制。使用*水平触发*，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

select和poll都需要通过遍历文件描述符获取已经就绪的socket，这导致效率很低。

### epoll

在2.6内核提出，epoll使用一个文件描述符管理多个描述符，将描述符的事件存储到事件表中，这样在用户空间到内核空间只需要复制一次。支持*边缘触发*，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次，使用事件通知，一旦fd就绪，内核会采取类似callback的回调机制激活该fd。epoll_wait()就可以收到通知。

优点：

1. 没有并发连接限制
2. 不采用轮询的方式，而是用事件通知，只有活跃的fd才会调用callback()
3. 使用mmap文件映射内存加速与内核空间的消息传递。

**消息传递方式**

![image.png](assets/image-20210827153934-mt7s6lo.png)

**最大连接数**

![image.png](assets/image-20210827153913-42xiy58.png)

**IO效率**

![image.png](assets/image-20210827154036-pohyyzo.png)

## 信号驱动式IO

socket注册一个信号处理函数，进程继续运行不会阻塞，当数据准备好时进程收到SIGIO信号，可以在信号处理函数中调用IO操作。

## 异步IO

异步IO不是顺序执行的，在执行系统调用后无论数据是否准备好都会直接返回给用户进程，等数据准备好后*内核复制数据到进程空间*，然后向进程发出通知。

![image.png](assets/image-20210827154858-y36giab.png)

前面的IO模型在第二阶段是阻塞的，而异步IO在两个阶段都是非阻塞的。

## 五种IO模型比较

![image.png](assets/image-20210827154947-a8uyf1j.png)